#include "mshdist.h"

#define BUCKSIZ       16
#define INIVAL_2d     0.25
#define INIVAL_3d     1.0

unsigned char inxt2[5] = {1,2,0,1,2};
unsigned char inxt3[7] = {1,2,3,0,1,2,3};
extern Info  info;


/* invert 3x3 non-symmetric matrix */
int invmatg(double m[9],double mi[9]) {
  double  aa,bb,cc,det,vmin,vmax,maxx;
  int     k;
  
  /* check ill-conditionned matrix */
  vmin = vmax = fabs(m[0]);
  for (k=1; k<9; k++) {
    maxx = fabs(m[k]);
    if ( maxx < vmin )  vmin = maxx;
    else if ( maxx > vmax )  vmax = maxx;
  }
  if ( vmax == 0.0 )  return(0);
  
  /* compute sub-dets */
  aa = m[4]*m[8] - m[5]*m[7];
  bb = m[5]*m[6] - m[3]*m[8];
  cc = m[3]*m[7] - m[4]*m[6];
  det = m[0]*aa + m[1]*bb + m[2]*cc;
  if ( fabs(det) < EPS1 )  return(0);
  det = 1.0f / det;
  
  mi[0] = aa*det;
  mi[3] = bb*det;
  mi[6] = cc*det;
  mi[1] = (m[2]*m[7] - m[1]*m[8])*det;
  mi[4] = (m[0]*m[8] - m[2]*m[6])*det;
  mi[7] = (m[1]*m[6] - m[0]*m[7])*det;
  mi[2] = (m[1]*m[5] - m[2]*m[4])*det;
  mi[5] = (m[2]*m[3] - m[0]*m[5])*det;
  mi[8] = (m[0]*m[4] - m[1]*m[3])*det;
  
  return(1);
}


/* return 0: no intersection, 1: intersection */
int intersec_2d(pPoint p1,pPoint p2,pPoint pa,pPoint pb) {
  double  det1,det2,det3,det4,ux,uy,vx,vy,wx,wy,zx,zy;

  ux = p2->c[0] - p1->c[0];
  uy = p2->c[1] - p1->c[1];
  vx = pa->c[0] - p1->c[0];
  vy = pa->c[1] - p1->c[1];
  det1 = ux*vy - vx*uy;

  wx = pb->c[0] - p1->c[0];
  wy = pb->c[1] - p1->c[1];
  det2 = ux*wy - wx*uy;

  /* coplanarity */
  if ( fabs(det1) < EPS1 && fabs(det2) < EPS1 ) {
    if ( fabs(pa->c[0]-pb->c[0]) < EPS1 ) {
      if ( wy*vy <= 0.0 )  return(1);
      if ( (uy-vy)*(uy-wy) <= 0.0 )  return(1);
      if ( wy*(uy-wy) >= 0.0 )  return(1);
    }
    else if ( fabs(pa->c[1]-pb->c[1]) < EPS1 ) {
      if ( wx*vx <= 0.0 )  return(1);
      if ( (ux-vx)*(ux-wx) <= 0.0 )  return(1);
      if ( wx*(ux-wx) >= 0.0 )  return(1);
    }

    return(0);
  }
  if ( det1*det2 > 0.0 )  return(0);

  zx = pb->c[0] - pa->c[0];
  zy = pb->c[1] - pa->c[1];
  det3 = vx*zy - zx*vy;
  det4 = zx*(uy-vy) - (ux-vx)*zy;

  if ( det3*det4 <= 0.0 )  return(1);

  return(0);
}


double distpt_2d(pPoint p1,pPoint p2,pPoint pa) {
  double   a,b,c,d,dd,ux,uy,vx,vy,wx,wy,xp,yp;
  
  a = p1->c[1] - p2->c[1];
  b = p2->c[0] - p1->c[0];
  c = -b*p1->c[1] - a*p1->c[0];
  d = INIVAL_2d;

  dd = a*a + b*b;
  if ( dd < EPS1 ) {
    d = (pa->c[0]-p1->c[0])*(pa->c[0]-p1->c[0]) + (pa->c[1]-p1->c[1])*(pa->c[1]-p1->c[1]);
    return(d);
  }
  xp =  b*b * pa->c[0] - a*b * pa->c[1] - a*c;
  yp = -a*b * pa->c[0] + a*a * pa->c[1] - b*c;
  dd = 1.0 / dd;
  xp *= dd;
  yp *= dd;

  ux = xp - p1->c[0];
  uy = yp - p1->c[1];
  vx = xp - p2->c[0];
  vy = yp - p2->c[1];
  wx = p2->c[0] - p1->c[0];
  wy = p2->c[1] - p1->c[1];

  if ( fabs(b) < EPS1 ) {
    if ( uy*wy <= 0.0 ) {
      d = (pa->c[0]-p1->c[0])*(pa->c[0]-p1->c[0]) + (pa->c[1]-p1->c[1])*(pa->c[1]-p1->c[1]);
      pa->tag = 2;
    }
    else if ( vy*wy <= 0.0 )
      d = (pa->c[0]-xp)*(pa->c[0]-xp) + (pa->c[1]-yp)*(pa->c[1]-yp);
    else {
      d = (pa->c[0]-p2->c[0])*(pa->c[0]-p2->c[0]) + (pa->c[1]-p2->c[1])*(pa->c[1]-p2->c[1]);
      pa->tag = 2;
    }
  }
  else {
    if ( ux*wx <= 0.0 ) {
      d = (pa->c[0]-p1->c[0])*(pa->c[0]-p1->c[0]) + (pa->c[1]-p1->c[1])*(pa->c[1]-p1->c[1]);
      pa->tag = 2;
    }
    else if ( vx*wx <= 0.0 )
      d = (pa->c[0]-xp)*(pa->c[0]-xp) + (pa->c[1]-yp)*(pa->c[1]-yp);
    else {
      d = (pa->c[0]-p2->c[0])*(pa->c[0]-p2->c[0]) + (pa->c[1]-p2->c[1])*(pa->c[1]-p2->c[1]);
      pa->tag = 2;
    }
  }

  return(d);
}


// au moins pour commencer (on pourra toujours optimiser apres...), la fonction suivante calcule [p,q,r,s] := det(q-p, r-p, s-p) en 3d...
double detOrient_3d(pPoint p,pPoint q,pPoint r,pPoint s) {
  double m11, m12, m13, m21, m22, m23, m31, m32, m33;
  
  m11 = q->c[0] - p->c[0]; 
  m21 = q->c[1] - p->c[1]; 
  m31 = q->c[2] - p->c[2]; 

  m12 = r->c[0] - p->c[0]; 
  m22 = r->c[1] - p->c[1]; 
  m32 = r->c[2] - p->c[2]; 
  
  m13 = s->c[0] - p->c[0]; 
  m23 = s->c[1] - p->c[1]; 
  m33 = s->c[2] - p->c[2];
  
  return(m11*m22*m33 + m12*m23*m31 + m13*m21*m32 - m31*m22*m13 - m32*m23*m11 - m33*m21*m12); 
}


//Pour calculer un determinant 3 x 3 avec des donnees un peu differentes...
double determinant3Pts1Vct_3d(pPoint p, pPoint q, pPoint r, pPoint v)
{
      // on calcule le determinant det(pq,pr, v)... p, q et r sont donc des points et v un vecteur
  double m11, m21, m31, m12, m22, m32;
  
  m11 = q->c[0] - p->c[0]; 
  m21 = q->c[1] - p->c[1]; 
  m31 = q->c[2] - p->c[2]; 
  
  m12 = r->c[0] - p->c[0]; 
  m22 = r->c[1] - p->c[1]; 
  m32 = r->c[2] - p->c[2];
  
  return(m11*m22*v->c[2] + m12*v->c[1]*m31 + v->c[0]*m21*m32 - m31*m22*v->c[0] - m32*v->c[1]*m11 - v->c[2]*m21*m12);
  
}



/* check intersection triangles p1q1r1 with p2q2e2 
   return 0: no intersection, 1: intersection */
int intersec_3d(pPoint p1,pPoint q1,pPoint r1,pPoint p2,pPoint q2,pPoint r2 ) {
  Point    prodVect; 
  pPoint   p1Prime, q1Prime, r1Prime,  p2Prime, q2Prime, r2Prime;
  double   orientp2, orientq2, orientr2, orientp1, orientq1, orientr1;
  int      renum1, renum2;

  // Un premier test permet de positionner un triangle par rapport au plan decrit par l autre
  // On commence par regarder les points du triangle p2q2r2 par rapport a ceux de p1q1r1
  
  orientp2 = detOrient_3d(p1, q1 , r1, p2); 
  orientq2 = detOrient_3d(p1, q1 , r1, q2);
  orientr2 = detOrient_3d(p1, q1 , r1, r2);
  
  // de meme, on oriente les points de T1 par rapport au plan de T2
  
  orientp1 = detOrient_3d(p2, q2 , r2, p1); 
  orientq1 = detOrient_3d(p2, q2 , r2, q1);
  orientr1 = detOrient_3d(p2, q2 , r2, r1);

  // si p2, q2 et r2 sont strictement du meme cote du plan decrit par T1, aucune intersection n est possible
  
  if(((orientp2>0.0)&&(orientq2>0.0)&&(orientr2>0.0))||((orientp2<0.0)&&(orientq2<0.0)&&(orientr2<0.0)))  //prendre une marge a epsilon pres ici
  { return(0);}
  
  // et symetriquement

  if(((orientp1>0.0)&&(orientq1>0.0)&&(orientr1>0.0))||((orientp1<0.0)&&(orientq1<0.0)&&(orientr1<0.0)))
  { return(0);}  
  
  //Deux autres cas particuliers sont a traiter : tout d abord celui ou les deux triangles sont coplanaires...
  
  if((fabs(orientp2)<0.0)&&(fabs(orientq2)<0.0)&&(fabs(orientr2)<0.0))   //prendre une marge aussi.
  {
    return(1);       //attention, bien sur, il n est pas toujours vrai de dire que si les deux triangles sont coplanaires, ils s intersectent necessairement !
                  // mais dnas le contexte dans lequel on va utiliser cette fonction, ce sera toujours le cas
  }
  
  // et le cas ou seul l'un des trois points p1,q1, r1 appartient au plan de T2 et ou les deux autres sont du meme cote de ce plan (et son symetrique)
  // Dans ce cas, il y aura intersection ssi le point en question appartient au triangle, ceci se testant au moyen de trois tests d orientation
  
  if((fabs(orientp1)< EPS1)&&(orientq1*orientr1>=0.0))  //prendre une marge a epsilon pres pour le test ==
  {
    //On calcule le produit vectoriel p2q2 /wedge p2r2 : il y a surement des optimisations a faire avec le calcul de determinants d avant
    
    prodVect.c[0] = (q2->c[1] - p2->c[1])*(r2->c[2] - p2->c[2]) - (q2->c[2] - p2->c[2])*(r2->c[1] - p2->c[1]);
    prodVect.c[1] = (q2->c[2] - p2->c[2])*(r2->c[0] - p2->c[0]) - (q2->c[0] - p2->c[0])*(r2->c[2] - p2->c[2]);
    prodVect.c[2] = (q2->c[0] - p2->c[0])*(r2->c[1] - p2->c[1]) - (q2->c[1] - p2->c[1])*(r2->c[0] - p2->c[0]);
    
    if((determinant3Pts1Vct_3d(p1, p2, q2, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(p1, q2, r2, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(p1, r2, p2, & prodVect) >=0.0))
    {return(1);}
    
    else {return(0);}
    
    }
  
  if((fabs(orientq1) < EPS1)&&(orientp1*orientr1>=0.0))  
  {
    //exactement la meme chose ici, sauf que l on regarde le point q1

    prodVect.c[0] = (q2->c[1] - p2->c[1])*(r2->c[2] - p2->c[2]) - (q2->c[2] - p2->c[2])*(r2->c[1] - p2->c[1]);
    prodVect.c[1] = (q2->c[2] - p2->c[2])*(r2->c[0] - p2->c[0]) - (q2->c[0] - p2->c[0])*(r2->c[2] - p2->c[2]);
    prodVect.c[2] = (q2->c[0] - p2->c[0])*(r2->c[1] - p2->c[1]) - (q2->c[1] - p2->c[1])*(r2->c[0] - p2->c[0]);
    
    if((determinant3Pts1Vct_3d(q1, p2, q2, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(q1, q2, r2, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(q1, r2, p2, & prodVect) >=0.0))
    {return 1;}
    
    else {return 0;}
  } 
  
  if((fabs(orientr1) < EPS1)&&(orientq1*orientp1>=0.0))  
  {   
    // et le point r1
    prodVect.c[0] = (q2->c[1] - p2->c[1])*(r2->c[2] - p2->c[2]) - (q2->c[2] - p2->c[2])*(r2->c[1] - p2->c[1]);
    prodVect.c[1] = (q2->c[2] - p2->c[2])*(r2->c[0] - p2->c[0]) - (q2->c[0] - p2->c[0])*(r2->c[2] - p2->c[2]);
    prodVect.c[2] = (q2->c[0] - p2->c[0])*(r2->c[1] - p2->c[1]) - (q2->c[1] - p2->c[1])*(r2->c[0] - p2->c[0]);
    
    if((determinant3Pts1Vct_3d(r1, p2, q2, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(r1, q2, r2, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(r1, r2, p2, & prodVect) >=0.0))
    {return 1;}
    
    else {return 0;}      
    }
  
  // on fait la meme chose pour les points du triangle T2
  
  if((fabs(orientp2) < EPS1)&&(orientq2*orientr2>=0.0))  //prendre une marge a epsilon pres pour le test ==
  {
    //On calcule le produit vectoriel p1q1 /wedge p1r1 : il y a surement des optimisations a faire avec le calcul de determinants d avant
    
    prodVect.c[0] = (q1->c[1] - p1->c[1])*(r1->c[2] - p1->c[2]) - (q1->c[2] - p1->c[2])*(r1->c[1] - p1->c[1]);
    prodVect.c[1] = (q1->c[2] - p1->c[2])*(r1->c[0] - p1->c[0]) - (q1->c[0] - p1->c[0])*(r1->c[2] - p1->c[2]);
    prodVect.c[2] = (q1->c[0] - p1->c[0])*(r1->c[1] - p1->c[1]) - (q1->c[1] - p1->c[1])*(r1->c[0] - p1->c[0]);
    
    if((determinant3Pts1Vct_3d(p2, p1, q1, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(p2, q1, r1, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(p2, r1, p1, & prodVect) >=0.0))
    {return(1);}
    
    else {return(0);}      
    }
  
  if((fabs(orientq2) < EPS1)&&(orientp2*orientr2>=0.0))  
  {
    prodVect.c[0] = (q1->c[1] - p1->c[1])*(r1->c[2] - p1->c[2]) - (q1->c[2] - p1->c[2])*(r1->c[1] - p1->c[1]);
    prodVect.c[1] = (q1->c[2] - p1->c[2])*(r1->c[0] - p1->c[0]) - (q1->c[0] - p1->c[0])*(r1->c[2] - p1->c[2]);
    prodVect.c[2] = (q1->c[0] - p1->c[0])*(r1->c[1] - p1->c[1]) - (q1->c[1] - p1->c[1])*(r1->c[0] - p1->c[0]);
    
    if((determinant3Pts1Vct_3d(q2, p1, q1, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(q2, q1, r1, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(q2, r1, p1, & prodVect) >=0.0))
    {return(1);}
    
    else {return(0);}
    
    } 
  
  if((fabs(orientr2) < EPS1)&&(orientq2*orientp2>=0.0))  
  {
    prodVect.c[0] = (q1->c[1] - p1->c[1])*(r1->c[2] - p1->c[2]) - (q1->c[2] - p1->c[2])*(r1->c[1] - p1->c[1]);
    prodVect.c[1] = (q1->c[2] - p1->c[2])*(r1->c[0] - p1->c[0]) - (q1->c[0] - p1->c[0])*(r1->c[2] - p1->c[2]);
    prodVect.c[2] = (q1->c[0] - p1->c[0])*(r1->c[1] - p1->c[1]) - (q1->c[1] - p1->c[1])*(r1->c[0] - p1->c[0]);
    
    if((determinant3Pts1Vct_3d(r2, p1, q1, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(r2, q1, r1, & prodVect) >=0.0)&&(determinant3Pts1Vct_3d(r2, r1, p1, & prodVect) >=0.0))
    {return(1);}
    
    return(0);
    
  } 
  
  // On a donc ecarte les cas ou les deux triangles sont coplanaires, ou l'un des deux est strictement d un seul cote du plan 
  // decrit par l autre, et ou l un des deux a un point dans le plan de l autre, et les deux autres points sont du meme cote.
  // Maintenant, on renumerote les points de sorte que p1 et q1 soient seuls du cote du plan de l autre triangle
  // les entiers renum serviront plus loin, pour marquer dans quel cas de figure on se trouve sans avoir besoin de refaire des tests compliques
  
  p1Prime = p2Prime = q1Prime = q2Prime = r1Prime = r2Prime = 0;

  if(((orientp1<0.0)&&(orientq1>=0.0)&&(orientr1>=0.0))||((orientp1>0.0)&&(orientq1<=0.0)&&(orientr1<=0.0)))  //prendre une marge a epsilon pres pour le test >
  {
      p1Prime = p1; 
    renum1 =1;
    
    }
  
  if(((orientq1<0.0)&&(orientp1>=0.0)&&(orientr1>=0.0))||((orientq1>0.0)&&(orientp1<=0.0)&&(orientr1<=0.0)))  //prendre une marge a epsilon pres pour le test >
  {
      p1Prime = q1; 
    renum1 =2 ;
    
    } 
  
  if(((orientr1<0.0)&&(orientq1>=0.0)&&(orientp1>=0.0))||((orientr1>0.0)&&(orientq1<=0.0)&&(orientp1<=0.0)))  //prendre une marge a epsilon pres pour le test >
  {
      p1Prime = r1; 
    renum1 = 3;
    }
  
  // on fait la meme chose pour les points du triangle T2
  
  if(((orientp2<0.0)&&(orientq2>=0.0)&&(orientr2>=0.0))||((orientp2>0.0)&&(orientq2<=0.0)&&(orientr2<=0.0)))  //prendre une marge a epsilon pres pour le test >
  {
      p2Prime = p2; 
    renum2 = 1;
    
    }
  
  if(((orientq2<0.0)&&(orientp2>=0.0)&&(orientr2>=0.0))||((orientq2>0.0)&&(orientp2<=0.0)&&(orientr2<=0.0)))  //prendre une marge a epsilon pres pour le test >
  {
      p2Prime = q2; 
    renum2 = 2;
    } 
  
  if(((orientr2<0.0)&&(orientq2>=0.0)&&(orientp2>=0.0))||((orientr2>0.0)&&(orientq2<=0.0)&&(orientp2<=0.0)))  //prendre une marge a epsilon pres pour le test >
  {
      p2Prime = r2; 
    renum2 = 3;
    }
  
  // Il faut alors pratiquer encore d autres tests et renumerotations pour s assurer que p2q2r2 tournent dans le sens trigo par rapport a p1 et reciproquement
  
  if((renum1 ==1)&&(renum2==1))
  {
    if(orientp2 >=0.0)
    {
      q1Prime = q1;
      r1Prime = r1;
    }
    
    else
    {
      q1Prime = r1;
      r1Prime = q1;
    }
    
    if(orientp1 >=0.0)
    {
      q2Prime = q2;
      r2Prime = r2;
    }
    
    else
    {
      q2Prime = r2;
      r2Prime = q2;
    }
  }
  
  if((renum1 ==1)&&(renum2==2))
  {
    if(orientq2 >=0.0)
    {
      q1Prime = q1;
      r1Prime = r1;
    }
    
    else
    {
      q1Prime = r1;
      r1Prime = q1;
    }
    
    if(orientp1 >=0.0)   //dans ce cas, il faut preserver le sens de rotation des points p2q2r2 dans l ecriture avec des "prime"
    {
      q2Prime = r2;
      r2Prime = p2;
    }
    
    else
    {
      q2Prime = p2;
      r2Prime = r2;
    }
  }
  
  if((renum1 ==1)&&(renum2==3))
  {
    if(orientr2 >=0.0)
    {
      q1Prime = q1;
      r1Prime = r1;
    }
    
    else
    {
      q1Prime = r1;
      r1Prime = q1;
    }
    
    if(orientp1 >=0.0)
    {
      q2Prime = p2;
      r2Prime = q2;
    }
    
    else
    {
      q2Prime = q2;
      r2Prime = p2;
    }
  }
  
  if((renum1 ==2)&&(renum2==1))
  {
    if(orientp2 >=0.0)
    {
      q1Prime = r1;
      r1Prime = p1;
    }
    
    else
    {
      q1Prime = p1;
      r1Prime = r1;
    }
    
    if(orientq1 >=0.0)
    {
      q2Prime = q2;
      r2Prime = r2;
    }
    
    else
    {
      q2Prime = r2;
      r2Prime = q2;
    }
  }
  
  if((renum1 ==2)&&(renum2==2))
  {
    if(orientq2 >=0.0)
    {
      q1Prime = r1;
      r1Prime = p1;
    }
    
    else
    {
      q1Prime = p1;
      r1Prime = r1;
    }
    
    if(orientq1 >=0.0)   //dans ce cas, il faut preserver le sens de rotation des points p2q2r2 dans l ecriture avec des "prime"
    {
      q2Prime = r2;
      r2Prime = p2;
    }
    
    else
    {
      q2Prime = p2;
      r2Prime = r2;
    }
  }
  
  if((renum1 ==2)&&(renum2==3))
  {
    if(orientr2 >=0.0)
    {
      q1Prime = r1;
      r1Prime = p1;
    }
    
    else
    {
      q1Prime = p1;
      r1Prime = r1;
    }
    
    if(orientq1 >=0.0)
    {
      q2Prime = p2;
      r2Prime = q2;
    }
    
    else
    {
      q2Prime = q2;
      r2Prime = p2;
    }
  }
  
  if((renum1 ==3)&&(renum2==1))
  {
    if(orientp2 >=0.0)
    {
      q1Prime = p1;
      r1Prime = q1;
    }
    
    else
    {
      q1Prime = q1;
      r1Prime = p1;
    }
    
    if(orientr1 >=0.0)
    {
      q2Prime = q2;
      r2Prime = r2;
    }
    
    else
    {
      q2Prime = r2;
      r2Prime = q2;
    }
  }
  
  if((renum1 ==3)&&(renum2==2))
  {
    if(orientq2 >=0.0)
    {
      q1Prime = p1;
      r1Prime = q1;
    }
    
    else
    {
      q1Prime = q1;
      r1Prime = p1;
    }
    
    if(orientr1 >=0.0)   //dans ce cas, il faut preserver le sens de rotation des points p2q2r2 dans l ecriture avec des "prime"
    {
      q2Prime = r2;
      r2Prime = p2;
    }
    
    else
    {
      q2Prime = p2;
      r2Prime = r2;
    }
  }
  
  if((renum1 ==3)&&(renum2==3))
  {
    if(orientr2 >=0.0)
    {
      q1Prime = p1;
      r1Prime = q1;
    }
    
    else
    {
      q1Prime = q1;
      r1Prime = p1;
    }
    
    if(orientr1 >=0.0)
    {
      q2Prime = p2;
      r2Prime = q2;
    }
    
    else
    {
      q2Prime = q2;
      r2Prime = p2;
    }
  }
  
  // ok, maintenant, c est bon, on a la configuration voulue ! il ne reste plus qu a conclure...
  assert(p1Prime);
  assert(p2Prime);
  assert(q1Prime);
  assert(q2Prime);
  assert(r1Prime);
  assert(r2Prime);
  
  return ((detOrient_3d(p1Prime, q1Prime, p2Prime, q2Prime)<=0.0)&&(detOrient_3d(p1Prime, r1Prime, r2Prime, p2Prime)<=0.0));   //idem, prendre une marge avec un eps>0
}


/* On calcule la distance de pq au triangle p0p1p2, 
   en appliquant une translation et deux rotations a l'ensemble */
double distpt_3d(pPoint p0,pPoint p1,pPoint p2,pPoint pq) {
  Point pointPlan0, pointPlan1, pointPlan2, pointPlana; 
  double lx1, ly1, lz1, lx2, ly2, lz2, lxq, lyq, lzq, longp0p1, cosAlpha, sinAlpha, aa, bb, ab, ll, l; 
  double p0XTemp, p0YTemp, p0ZTemp, p1XTemp, p1YTemp, p1ZTemp, p2XTemp, p2YTemp, p2ZTemp, pqXTemp, pqYTemp, pqZTemp; // pour stocker temporairement
                                // les coordonnees des points apres les differentes transformations en jeu; 
  
  double m11, m12, m13, m21, m22, m23, m31, m32, m33, d01, d12, d02, dTmp;
  double zone01, zone02, zone12;
  
  
  lx1 = p1->c[0] - p0->c[0]; //les coordonnees du vecteur p0p1
  ly1 = p1->c[1] - p0->c[1];  
  lz1 = p1->c[2] - p0->c[2];  
  
  lx2 = p2->c[0] - p0->c[0]; //les coordonnees du vecteur p0p2
  ly2 = p2->c[1] - p0->c[1];  
  lz2 = p2->c[2] - p0->c[2];    
  
  lxq = pq->c[0] - p0->c[0]; 
  lyq = pq->c[1] - p0->c[1]; 
  lzq = pq->c[2] - p0->c[2];
  
  longp0p1 = sqrt(lx1*lx1 + ly1*ly1 + lz1*lz1); 
  
  cosAlpha = lz1/longp0p1; //le cosinus de l angle entre p0p1 et le vecteur de base ez
  sinAlpha = sqrt(1.0-cosAlpha*cosAlpha); //on lui met le signe + parce que par definition, on tournera dans ce sens, vu l axe choisi plus loin
  
  
  //application de la translation de vecteur Op0
  
  p0XTemp = 0.0;
  p0YTemp = 0.0;
  p0ZTemp = 0.0; 
  p1XTemp = lx1; 
  p1YTemp = ly1; 
  p1ZTemp = lz1;
  p2XTemp = lx2; 
  p2YTemp = ly2; 
  p2ZTemp = lz2;  
  pqXTemp = lxq; 
  pqYTemp = lyq; 
  pqZTemp = lzq;
  
  // application de la rotation d angle alpha
  //calcul des coefficients de la matrice
  
  aa = lx1*lx1;
  bb = ly1*ly1; 
  ab = lx1*ly1;
  ll = aa + bb;
  l = sqrt(ll);
  
  m11 = (aa*cosAlpha + bb)/ll;
  m12 = (ab*cosAlpha - ab )/ll;
  m13 = -lx1*sinAlpha/l;
  
  m21 = (ab * cosAlpha - ab)/ll;
  m22 = (bb*cosAlpha + aa)/ll;
  m23 = - ly1 * sinAlpha/l; 
  
  m31 = (lx1* sinAlpha)/l;
  m32 = (ly1 * sinAlpha)/l;
  m33 = cosAlpha;   

 
  // et on applique la rotation
  
  p1XTemp = m11*lx1 + m12*ly1 + m13 * lz1;    //le point P1 passe sur l axe oz dans le sens positif, comme on voulait.
  p1YTemp = m21*lx1 + m22*ly1 + m23 * lz1;
  p1ZTemp = longp0p1; 
  
  p2XTemp = m11*lx2 + m12*ly2 + m13 * lz2;
  p2YTemp = m21*lx2 + m22*ly2 + m23 * lz2;  
  p2ZTemp = m31*lx2 + m32*ly2 + m33 * lz2;  
  
  pqXTemp = m11*lxq + m12*lyq + m13 * lzq;
  pqYTemp = m21*lxq + m22*lyq + m23 * lzq;  
  pqZTemp = m31*lxq + m32*lyq + m33 * lzq;
  
  // On applique maintenant une seconde rotation pour ramener le point p2 dans le plan (yz), dans le demi plan y>0 (celle-la ne bugge pas)
  
  cosAlpha = p2YTemp/(sqrt(p2XTemp* p2XTemp + p2YTemp* p2YTemp)); 
  sinAlpha = sqrt(1.0-cosAlpha * cosAlpha);
  if(p2XTemp <=0.0) {sinAlpha = -sinAlpha; }  //dans ce cas, on veut ramener p2 dans le plan x = 0 donc il faut tourner de moins alpha
                              // dans le cas contraire,on tournera bien dans le sens trigonometrique
  
  
  // et on applique simplement la rotation d axe Oz et d angle alpha ainsi calculee
  
  lx2 = 0.0;      //les coordonnees du point p2 final
  ly2 = sinAlpha * p2XTemp + cosAlpha * p2YTemp; 
  lz2 = p2ZTemp;       // comme par définition, on fait une rotation d axe Oz, ca ne change pas...
  
  lxq = cosAlpha * pqXTemp - sinAlpha * pqYTemp;     // les coordonnees du point pq final
  lyq = sinAlpha * pqXTemp + cosAlpha * pqYTemp; 
  lzq = pqZTemp; 
  
  //on ecrit trois determinants 2*2 qui vont permettre de reperer la projection du nouveau pq dans ce triangle (qui est seulement donnee
  // par ses deux dernieres coordonnees)
  
  zone01 = lyq; // dans ce cas, ce n est pas un determinant: comme p1 est sur Oz, savoir si on est a gauche ou a droite se voit sur la composante y)
  zone02 = ly2*lzq - lz2*lyq; // sera positif ssi on est du cote du triangle p0p1p2; 
  zone12 = lyq*(lz2-longp0p1) - ly2*(lzq - longp0p1); //idem : c est det(p1pq, p1p2) dans le plan considere
  
  //enfin, on peut decider du calcul de la distance, en fonction de ce reperage de zones...
  
  if((zone01>=0.0)&&(zone02 >=0.0)&&(zone12>=0.0))
  {
     return (lxq*lxq);     //dans ce cas, c'est simplement la distance au plan
  }

  else
  {
     pointPlan0.c[0] = 0.0;
     pointPlan0.c[1] = 0.0; 
        
     pointPlan1.c[0] = 0.0; 
     pointPlan1.c[1] = longp0p1;
        
     pointPlan2.c[0] = ly2; 
     pointPlan2.c[1] = lz2;     

     pointPlana.c[0] = lyq; 
     pointPlana.c[1] = lzq;

     d01 = distpt_2d(&pointPlan0, &pointPlan1, &pointPlana);
     d02 = distpt_2d(&pointPlan0, &pointPlan2, &pointPlana);
     d12 = distpt_2d(&pointPlan1, &pointPlan2, &pointPlana);

     dTmp = D_MIN(d01, D_MIN(d02, d12)); 
     pq->tag=2;
    
     return(dTmp + lxq*lxq);
  }

}


int interSegTria(pMesh mesh,pPoint pa,pPoint pb,pTria pt) {
  pPoint   p1,p2,p3;
  Point    v;
  double   d1,d2,d3,dd;

  p1 = &mesh->point[pt->v[0]];
  p2 = &mesh->point[pt->v[1]];
  p3 = &mesh->point[pt->v[2]];

  d1 = detOrient_3d(p1,p2,p3,pa);
  d2 = detOrient_3d(p1,p2,p3,pb);
  if ( d1*d2 > 0.0 )  return(0);

  v.c[0] = pb->c[0] - pa->c[0];
  v.c[1] = pb->c[1] - pa->c[1];
  v.c[2] = pb->c[2] - pa->c[2];
  d1 = determinant3Pts1Vct_3d(p1,p2,p3,&v);
  d2 = determinant3Pts1Vct_3d(p1,p2,pb,&v);
  d3 = determinant3Pts1Vct_3d(p1,pb,p3,&v);
  dd = d2 * d3;
  if ( dd <= 0.0 || d2*d1 <= 0.0 )  return(0);

  d1 = determinant3Pts1Vct_3d(p2,p3,p1,&v);
  d2 = determinant3Pts1Vct_3d(p2,p3,pb,&v);
  d3 = determinant3Pts1Vct_3d(p2,pb,p1,&v);
  dd = d2 * d3;
  if ( dd <= 0.0 || d2*d1 <= 0.0 )  return(0);

  return(1);
}


/* assign a sign on distance value and check connected components */
int sgndist_3d(pMesh mesh,pSol sol,pBucket bucket) {
  pTetra   pt,pt1;
  pPoint   ppt,pi;
  double   p[3],cb[4];
  int     *pile,*adja,*pilcc,*tmpil,i,j,k,cc,kk,iel,base,bfin,iadr,ipile,ipilc,start,nbi,np,ip;
  char     sgn,plus,minus;

  /* memory alloc */
  pile = (int*)calloc(mesh->ne+1,sizeof(int));
  assert(pile);

  /* identify element close to outer bdry */
  p[0] = 0.02;
  p[1] = 0.02;
  p[2] = 0.02;
  iel = buckin(mesh,bucket,p);
  iel = locelt(mesh,iel,p,cb);
  assert(iel);

  /* reset colors */
  for (k=1; k<=mesh->ne; k++)  mesh->tetra[k].flag = 0;
  mesh->flag  = 0;
  ipile       = 1;
  pile[ipile] = iel;
  base = ++mesh->flag;
  pt   = &mesh->tetra[iel];
  pt->flag = base;
  start    = 1;
  while ( ipile > 0 ) {
    do {
      k = pile[ipile];
      ipile--;

      pt = &mesh->tetra[k];
      iadr = 4*(k-1) + 1;
      adja = &mesh->adja[iadr];
      for (i=0; i<4; i++) {
        if ( !adja[i] )  continue;
        kk  = adja[i] / 4;
        pt1 = &mesh->tetra[kk];
        nbi = 0;
        for (j=0; j<4; j++)
          if ( sol->val[ pt1->v[j] ] < INIVAL_3d )  nbi++;
        if ( nbi < 4 && pt1->flag < base ) {
          ipile++;
          pile[ipile] = kk;
          pt1->flag   = base;
        }
      }
    }
    while ( ipile > 0 );

    /* find next component */
    ipile = 0;
    for (k=start; k<=mesh->ne; k++) {
      pt = &mesh->tetra[k];
      if ( pt->flag >= 1 )  continue;
      for (i=0; i<4; i++)
        if ( sol->val[pt->v[i]] < INIVAL_3d )  break;
      if ( i == 4 ) {
        base = ++mesh->flag;
        ipile = 1;
        pile[ipile] = k;
        pt->flag    = base;
        break;
      }
    }
  }

  /* analyze components */
  if ( fabs(info.imprim) > 3 )  fprintf(stdout,"     %d connected component(s)\n",base);

  /* store triangles intersected */
  bfin  = mesh->flag;
  sgn   = 1;
  pilcc = (int*)calloc(bfin+2,sizeof(int));
  assert(pilcc);
  base  = ++mesh->flag;
  pilcc[1] = base;
  do {
    for (k=1; k<=mesh->ne; k++) {
      pt = &mesh->tetra[k];
      if ( pt->flag < 1 )  continue;
      for (cc=1; cc<=bfin; cc++) {
        if ( pilcc[cc] == base && pt->flag == cc ) {
          iadr = 4*(k-1) + 1;
          adja = &mesh->adja[iadr];
          for (i=0; i<4; i++) {
            if ( !adja[i] )  continue;
            kk  = adja[i] / 4;
            pt1 = &mesh->tetra[kk];
            if ( pt1->flag == 0 ) {
              ipile++;
              pile[ipile] = kk;
              pt1->flag   = -1;
            }
          }
        }
      }
    }
    if ( !ipile )  break;

    while ( ipile > 0 ) {
      k = pile[ipile];
      ipile--;
      pt = &mesh->tetra[k];
      iadr = 4*(k-1) + 1;
      adja = &mesh->adja[iadr];
      for (i=0; i<4; i++) {
        if ( !adja[i] )  continue;
        kk  = adja[i] / 4;
        pt1 = &mesh->tetra[kk];
        if ( pt1->flag == 0 ) {
          ipile++;
          pile[ipile] = kk;
          pt1->flag   = -1;
        }
        else if ( pt1->flag > 0 && pilcc[pt1->flag] != base )
          pilcc[pt1->flag] = base + 1;
      }
    }

    if ( info.ddebug ) {
      printf("     component list: ");
      for (cc=1; cc<=bfin; cc++)
        if ( pilcc[cc] == base )  printf(" %d  ",cc);
      printf("\n");
    }

    /* update sign */
    base = ++mesh->flag;
    sgn  = -sgn;
    for (i=1; i<=bfin; i++) {
      if ( pilcc[i] != base )  continue; 
      for (k=1; k<=mesh->ne; k++) {
        pt = &mesh->tetra[k];
        if ( pt->flag == i ) {
          for (j=0; j<4; j++) {
            ppt = &mesh->point[pt->v[j]];
            if ( ppt->flag < base ) {
              sol->val[pt->v[j]] = sgn * fabs(sol->val[pt->v[j]]);
              ppt->flag = base;
              np++;
            }
          }
        }
      }
    }
  }
  while ( 1 );

  np = 0;
  for (k=1; k<=mesh->np; k++) {
    if ( !mesh->point[k].flag && fabs(sol->val[k]) < INIVAL_3d ) {
      np++;
    }
  }

  if ( np ) {
    fprintf(stdout,"  %%%% %d vertices non flagged\n",np);
    ipile = 0;
    for (k=1; k<=mesh->ne; k++) {
      pt = &mesh->tetra[k];
      for (i=0; i<4; i++) {
        ppt = &mesh->point[pt->v[i]];
        if ( !ppt->flag && fabs(sol->val[pt->v[i]]) < INIVAL_3d ) {
          ipile++;
          pile[ipile] = k;
          break;
        }
      }
    }
		printf("pile = %d\n",ipile);

    pilcc = (int*)realloc(pilcc,(ipile+1)*sizeof(int));
    assert(pilcc);
    do {
      ipilc = 0;
			np    = 0;
      for (k=1; k<=ipile; k++) {
        pt = &mesh->tetra[k];
        plus  = minus = 0;
				pi = 0;
				ip = 0;
        for (i=0; i<4; i++) {
          ppt = &mesh->point[pt->v[i]];
          if ( ppt->flag ) { 
            if ( sol->val[pt->v[i]] > 0.0 )       plus++;
            else if ( sol->val[pt->v[i]] < 0.0 )  minus++;
          }
          else {
            pi = ppt;
            ip = pt->v[i];
          }
        }
				if ( !ip )  continue;
        else if ( plus == 3 ) { 
          sol->val[ip] = -sol->val[ip];
					assert(pi);
          pi->flag    = 1;
					np++;
        }
        else if ( minus == 3 ) {
					assert(pi);
          pi->flag = 1;
					np++;
				}
        else 
          pilcc[++ipilc] = k;
      }
			printf("ipilc = %d   np %d\n",ipilc,np);
			tmpil = pile;
			pile  = pilcc;
			pilcc = tmpil;
			ipile = ipilc;
    }
    while ( np > 0 );

    /* special processing */
  }

  free(pilcc);
  free(pile);

  /* take sqrt of distance */
  for (k=1; k<=mesh->np; k++) {
    sol->val[k] = sol->val[k] < 0.0 ? -sqrt(fabs(sol->val[k])) : sqrt(sol->val[k]);
  }

  return(1);
}


int sgndist_2d(pMesh mesh,pSol sol,pBucket bucket) {
  pTria    pt,pt1;
	pPoint   ppt,pi;
  double   p[2],cb[3];
  int     *pile,*adja,*pilcc,*tmpil,i,j,k,cc,kk,iel,base,bfin,iadr,ipile,start,nbi,np,ipilc,ip;
  char     sgn,plus,minus;

  /* memory alloc */
  pile = (int*)calloc(mesh->nt+1,sizeof(int));
  assert(pile);

  /* identify triangleclose to outer bdry */
  p[0] = 0.02;
  p[1] = 0.02;
  iel = buckin(mesh,bucket,p);
  iel = locelt(mesh,iel,p,cb);
  assert(iel);

  /* reset colors */
  for (k=1; k<=mesh->nt; k++)  mesh->tria[k].flag = 0;
  mesh->flag = 0;

  ipile       = 1;
  pile[ipile] = iel;
  base = ++mesh->flag;
  pt   = &mesh->tria[iel];
  pt->flag = base;
  start    = 1;
  while ( ipile > 0 ) {
    do {
      k = pile[ipile];
      ipile--;

      pt = &mesh->tria[k];
      iadr = 3*(k-1) + 1;
      adja = &mesh->adja[iadr];
      for (i=0; i<3; i++) {
        if ( !adja[i] )  continue;
        kk  = adja[i] / 3;
        pt1 = &mesh->tria[kk];
        nbi = 0;
        for (j=0; j<3; j++)
          if ( sol->val[ pt1->v[j] ] < INIVAL_2d )  nbi++;
        if ( nbi < 3 && pt1->flag < base ) {
          ipile++;
          pile[ipile] = kk;
          pt1->flag   = base;
        }
      }
    }
    while ( ipile > 0 );

    /* find next component */
    ipile = 0;
    for (k=start; k<=mesh->nt; k++) {
      pt = &mesh->tria[k];
      if ( pt->flag >= 1 )  continue;
      for (i=0; i<3; i++)
        if ( sol->val[pt->v[i]] < INIVAL_2d )  break;
      if ( i == 3 ) {
        base = ++mesh->flag;
        ipile = 1;
        pile[ipile] = k;
        pt->flag = base;
        break;
      }
    }
  }

  if ( info.ddebug ) {
    FILE  *out;
    out = fopen("titi.sol","w");
    fprintf(out,"MeshVersionFormatted 1\n");
    fprintf(out,"Dimension 2\n");
    fprintf(out,"SolAtTriangles\n%d\n%d %d\n",mesh->nt,1,1);
    for (k=1; k<=mesh->nt; k++)
      fprintf(out,"%d\n",mesh->tria[k].flag);
    fclose(out);
  }

  /* analyze components */
  if ( fabs(info.imprim) > 3 )  fprintf(stdout,"     %d connected component(s)\n",base);
  if ( base < 2 )  return(-1);

  /* store triangles intersected */
  bfin  = mesh->flag;
  sgn   = 1;
  pilcc = (int*)calloc(bfin+2,sizeof(int));
  assert(pilcc);
  base  = ++mesh->flag;
  pilcc[1] = base;
  do {
    for (k=1; k<=mesh->nt; k++) {
      pt = &mesh->tria[k];
      if ( pt->flag < 1 )  continue;
      for (cc=1; cc<=bfin; cc++) {
        if ( pilcc[cc] == base && pt->flag == cc ) {
          iadr = 3*(k-1) + 1;
          adja = &mesh->adja[iadr];
          for (i=0; i<3; i++) {
            if ( !adja[i] )  continue;
            kk  = adja[i] / 3;
            pt1 = &mesh->tria[kk];
            if ( pt1->flag == 0 ) {
              ipile++;
              pile[ipile] = kk;
              pt1->flag   = -1;
            }
          }
        }
      }
    }
    if ( !ipile )  break;

    while ( ipile > 0 ) {
      k = pile[ipile];
      ipile--;
      pt = &mesh->tria[k];
      iadr = 3*(k-1) + 1;
      adja = &mesh->adja[iadr];
      for (i=0; i<3; i++) {
        if ( !adja[i] )  continue;
        kk  = adja[i] / 3;
        pt1 = &mesh->tria[kk];
        if ( pt1->flag == 0 ) {
          ipile++;
          pile[ipile] = kk;
          pt1->flag   = -1;
        }
        else if ( pt1->flag > 0 && pilcc[pt1->flag] != base )
          pilcc[pt1->flag] = base + 1;
      }
    }

    if ( info.ddebug ) {
      printf("     component list: ");
      for (cc=1; cc<=bfin; cc++)
        if ( pilcc[cc] == base )  printf(" %d  ",cc);
      printf("\n");
    }

    /* update sign */
    base = ++mesh->flag;
    sgn = -sgn;
    for (i=1; i<=bfin; i++) {
      if ( pilcc[i] != base )  continue; 
      for (k=1; k<=mesh->nt; k++) {
        pt = &mesh->tria[k];
        if ( pt->flag == i ) {
          for (j=0; j<3; j++) {
						//ppt = &mesh->point[pt->v[j]];
						//if ( ppt->flag < base ) {
              sol->val[pt->v[j]] = sgn * fabs(sol->val[pt->v[j]]);
							//ppt->flag = base;
						//}
					}
        }
      }
    }
  }
  while ( 1 );

  np = 0;
  for (k=1; k<=mesh->np; k++) {
    if ( !mesh->point[k].flag && fabs(sol->val[k]) < INIVAL_2d ) {
      np++;
    }
  }

  if ( np ) {
    fprintf(stdout,"  %%%% %d vertices non flagged\n",np);
    ipile = 0;
    for (k=1; k<=mesh->nt; k++) {
      pt = &mesh->tria[k];
      for (i=0; i<3; i++) {
        ppt = &mesh->point[pt->v[i]];
        if ( !ppt->flag && fabs(sol->val[pt->v[i]]) < INIVAL_2d ) {
          ipile++;
          pile[ipile] = k;
          break;
        }
      }
    }
		printf("pile = %d\n",ipile);

    pilcc = (int*)realloc(pilcc,(ipile+1)*sizeof(int));
    assert(pilcc);
    do {
      ipilc = 0;
			np    = 0;
      for (k=1; k<=ipile; k++) {
        pt = &mesh->tria[k];
        plus  = minus = 0;
				pi = 0;
				ip = 0;
        for (i=0; i<3; i++) {
          ppt = &mesh->point[pt->v[i]];
          if ( ppt->flag ) { 
            if ( sol->val[pt->v[i]] > 0.0 )       plus++;
            else if ( sol->val[pt->v[i]] < 0.0 )  minus++;
          }
          else {
            pi = ppt;
            ip = pt->v[i];
          }
        }
				if ( !ip )  continue;
        else if ( plus == 2 ) { 
          sol->val[ip] = -sol->val[ip];
					assert(pi);
          pi->flag    = 1;
					np++;
        }
        else if ( minus == 2 ) {
					assert(pi);
          pi->flag = 1;
					np++;
				}
        else 
          pilcc[++ipilc] = k;
      }
			printf("ipilc = %d   np %d\n",ipilc,np);
			tmpil = pile;
			pile  = pilcc;
			pilcc = tmpil;
			ipile = ipilc;
    }
    while ( np > 0 );

    /* special processing */
  }

  free(pilcc);
  free(pile);

  /* take sqrt of distance */
  for (k=1; k<=mesh->np; k++) {
    sol->val[k] = sol->val[k] < 0.0 ? -sqrt(fabs(sol->val[k])) : sqrt(sol->val[k]);
    //if ( !mesh->point[k].flag )
			//sol->val[k] = -10;
  }

  return(1);
}


int inidist_3d(pMesh mesh1,pMesh mesh2,pSol sol1,pBucket bucket) {
  pTetra   pt,pt1;
  pTria    pf;
  pPoint   p1,p2, p3, pa,pb, pc;
  double   cb[4],d;
  int     *adja,*list,base,iadr,ilist,tag,i,j,k,ia,ib, ic,nc, iel,jel,ier,cur;
  
  /* memory alloc */
  list = (int*)calloc(mesh1->ne+1,sizeof(int));   
  assert(list);
  
  nc = 0;
  for (k=1; k<=mesh2->nt; k++) {
    pf = &mesh2->tria[k];         
    p1 = &mesh2->point[pf->v[0]];
    p2 = &mesh2->point[pf->v[1]];
    p3 = &mesh2->point[pf->v[2]];

    iel = buckin(mesh1,bucket,p1->c);
    iel = locelt(mesh1,iel,p1->c,cb);
    assert(iel);
    ilist       = 1;            
    list[ilist] = iel;           
    base = ++mesh1->flag;         
    pt   = &mesh1->tetra[iel];
    pt->flag = base;

    cur = 1;
    do {
      iel  = list[cur];
      pt   = &mesh1->tetra[iel];
      iadr = 4*(iel-1) + 1;
      adja = &mesh1->adja[iadr];
      for (i=0; i<4; i++) {
        ia = inxt3[i];
        ib = inxt3[ia];
        ic = inxt3[ib];
        pa = &mesh1->point[pt->v[ia]];      
        pb = &mesh1->point[pt->v[ib]];     
        pc = &mesh1->point[pt->v[ic]]; 
        ier = intersec_3d(p1,p2,p3,pa,pb,pc);

        if ( ier ) {
          pt->tag = 1;
          jel = adja[i] / 4;
          pt1 = &mesh1->tetra[jel];
          if ( jel && (pt1->flag < base) ) {
            ilist++;
            list[ilist] = jel;
            pt1->flag   = base;
          }
        }
      }
      cur++;
    }
    while ( cur <= ilist );

    /* list analysis */
    for (i=1; i<=ilist; i++) {
      iel = list[i];
      pt  = &mesh1->tetra[iel];
      for (j=0; j<4; j++) {
        ia = pt->v[j];
        pa = &mesh1->point[ia];
        tag = pa->tag;
        d  = distpt_3d(p1,p2, p3, pa);
        if ( d < sol1->val[ia] )
          sol1->val[ia] = d;
        else 
          pa->tag = tag;
      }
    }
  }
  fprintf(stdout,"     distance\n");

  /* correction */
  nc = 0;
  for (k=1; k<=mesh1->np; k++) {
    pa = &mesh1->point[k];
    if ( pa->tag < 2 )  continue;
    for (i=1; i<=mesh2->nt; i++) {
      pf = &mesh2->tria[i];
      p1 = &mesh2->point[pf->v[0]];      
      p2 = &mesh2->point[pf->v[1]];       
      p3 = &mesh2->point[pf->v[2]];       
      d  = distpt_3d(p1,p2,p3,pa);
      sol1->val[k] = D_MIN(sol1->val[k],d);
    }
    pa->tag = 1;
    nc++;
  }
  if ( nc )  fprintf(stdout,"     %d correction(s)\n",nc);

  free(list);
  return(1);

}


int inidist_2d(pMesh mesh1,pMesh mesh2,pSol sol1,pBucket bucket) {
  pTria    pt,pt1;
  pEdge    pe;
  pPoint   p1,p2,pa,pb;
  double   cb[3],d;
  int     *adja,*list,base,iadr,ilist,i,j,k,ia,ib,iel,jel,ier,cur,nc,tag;

  /* memory alloc */
  list = (int*)calloc(mesh1->np+1,sizeof(int));
  assert(list);

  nc = 0;
  for (k=1; k<=mesh2->na; k++) {
    pe  = &mesh2->edge[k];
    p1  = &mesh2->point[pe->v[0]];
    p2  = &mesh2->point[pe->v[1]];
    iel = buckin(mesh1,bucket,p1->c);
    iel = locelt(mesh1,iel,p1->c,cb);
    assert(iel);

    ilist       = 1;
    list[ilist] = iel;
    base = ++mesh1->flag;
    pt   = &mesh1->tria[iel];
    pt->flag = base;
    
    cur = 1;
    do {
      iel  = list[cur];
      pt   = &mesh1->tria[iel];
      iadr = 3*(iel-1) + 1;
      adja = &mesh1->adja[iadr];
      for (i=0; i<3; i++) {
        ia = inxt2[i];
        ib = inxt2[ia];
        pa = &mesh1->point[pt->v[ia]];      
        pb = &mesh1->point[pt->v[ib]];       
        ier = intersec_2d(p1,p2,pa,pb);
        if ( ier ) {
          jel = adja[i] / 3;
          pt1 = &mesh1->tria[jel];
          if ( jel && pt1->flag < base ) {
            ilist++;
            list[ilist] = jel;
            pt1->flag   = base;
          }
        }
      }
      cur++;
    }
    while ( cur <= ilist );

    /* list analysis */
    for (i=1; i<=ilist; i++) {
      iel = list[i];
      pt  = &mesh1->tria[iel];
      for (j=0; j<3; j++) {
        ia = pt->v[j];
        pa = &mesh1->point[ia];
        tag = pa->tag;
        d  = distpt_2d(p1,p2,pa);
        if ( d < sol1->val[ia] )
          sol1->val[ia] = d;
        else
          pa->tag = tag;
      }
    }
  }

  /* correction */
  nc = 0;
  for (k=1; k<=mesh1->np; k++) {
    pa = &mesh1->point[k];
    if ( pa->tag < 2 )  continue;
    for (i=1; i<=mesh2->na; i++) {
      pe = &mesh2->edge[i];
      p1 = &mesh2->point[pe->v[0]];      
      p2 = &mesh2->point[pe->v[1]];       
      d  = distpt_2d(p1,p2,pa);
      sol1->val[k] = D_MIN(sol1->val[k],d);
    }
    pa->tag = 1;
    nc++;
  }
  if ( nc )   fprintf(stdout,"     %d correction(s)\n",nc);

  free(list);
  return(1);
}


/* expand distance function to the entire domain by solving the Eikonal eq. using characteristics */
int ppgdist_3d(pMesh mesh, pSol sol) {  
  pTetra    pt,pt1;
  pPoint    p0,p1,p2,p3;
  double   *gradients,*dtmp,drec,dx,dy,dz,dt,dd,p[3],cb[4],m[9],mi[9],res0,res;
  int       j,k,iadr,maxit,it,iel,ier,ip,base;
  
  /* memory alloc */
  gradients = (double*)calloc(16*(mesh->ne)+1,sizeof(double));
  assert(gradients);

  /* compute gradients of shape functions P1: 16 values (dx,dy,dz,cte) */
  for(k=1; k<=mesh->ne; k++) {
    pt = &mesh->tetra[k]; 
    p0 = &mesh->point[pt->v[0]];
    p1 = &mesh->point[pt->v[1]];
    p2 = &mesh->point[pt->v[2]];
    p3 = &mesh->point[pt->v[3]];
    
    /* lambda_0 */
    m[0] = p1->c[0] - p0->c[0]; 
    m[1] = p1->c[1] - p0->c[1];
    m[2] = p1->c[2] - p0->c[2];
    m[3] = p2->c[0] - p0->c[0];
    m[4] = p2->c[1] - p0->c[1];
    m[5] = p2->c[2] - p0->c[2];
    m[6] = p3->c[0] - p0->c[0];
    m[7] = p3->c[1] - p0->c[1];
    m[8] = p3->c[2] - p0->c[2];

    ier = invmatg(m,mi); 
    iadr = 16 * (k-1) + 1;
    gradients[iadr + 0] = -mi[0] - mi[1] - mi[2];
    gradients[iadr + 1] = -mi[3] - mi[4] - mi[5];
    gradients[iadr + 2] = -mi[6] - mi[7] - mi[8];
    gradients[iadr + 3] = 1.0 - gradients[iadr+0]*p0->c[0] - gradients[iadr+1]*p0->c[1] 
                              - gradients[iadr+2]*p0->c[2];
    /* lambda_1 */    
    m[0] = p0->c[0] - p1->c[0]; 
    m[1] = p0->c[1] - p1->c[1];
    m[2] = p0->c[2] - p1->c[2];
    m[3] = p2->c[0] - p1->c[0];
    m[4] = p2->c[1] - p1->c[1];
    m[5] = p2->c[2] - p1->c[2];
    m[6] = p3->c[0] - p1->c[0];
    m[7] = p3->c[1] - p1->c[1];
    m[8] = p3->c[2] - p1->c[2];
    
    ier = invmatg(m,mi); 
    gradients[iadr + 4] = -mi[0] - mi[1] - mi[2];
    gradients[iadr + 5] = -mi[3] - mi[4] - mi[5];
    gradients[iadr + 6] = -mi[6] - mi[7] - mi[8];
    gradients[iadr + 7] = 1.0 - gradients[iadr+4]*p1->c[0] - gradients[iadr+5]*p1->c[1] 
                              - gradients[iadr+6]*p1->c[2];
    //lambda_2
    m[0] = p0->c[0] - p2->c[0]; 
    m[1] = p0->c[1] - p2->c[1];
    m[2] = p0->c[2] - p2->c[2];
    m[3] = p1->c[0] - p2->c[0];
    m[4] = p1->c[1] - p2->c[1];
    m[5] = p1->c[2] - p2->c[2];
    m[6] = p3->c[0] - p2->c[0];
    m[7] = p3->c[1] - p2->c[1];
    m[8] = p3->c[2] - p2->c[2];
    
    ier = invmatg(m,mi); 
    gradients[iadr + 8] = -mi[0] - mi[1] - mi[2];
    gradients[iadr + 9] = -mi[3] - mi[4] - mi[5];
    gradients[iadr +10] = -mi[6] - mi[7] - mi[8];
    gradients[iadr +11] = 1.0 - gradients[iadr+8]*p2->c[0] - gradients[iadr+9]*p2->c[1]
                              - gradients[iadr+10]*p2->c[2];
    /* lambda_3 */
    m[0] = p0->c[0] - p3->c[0]; 
    m[1] = p0->c[1] - p3->c[1];
    m[2] = p0->c[2] - p3->c[2];
    m[3] = p1->c[0] - p3->c[0];
    m[4] = p1->c[1] - p3->c[1];
    m[5] = p1->c[2] - p3->c[2];
    m[6] = p2->c[0] - p3->c[0];
    m[7] = p2->c[1] - p3->c[1];
    m[8] = p2->c[2] - p3->c[2];
    
    ier = invmatg(m,mi); 
    gradients[iadr +12] = -mi[0] - mi[1] - mi[2];
    gradients[iadr +13] = -mi[3] - mi[4] - mi[5];
    gradients[iadr +14] = -mi[6] - mi[7] - mi[8];
    gradients[iadr +15] = 1.0 - gradients[iadr+12]*p3->c[0] - gradients[iadr+13]*p3->c[1] 
                              - gradients[iadr+14]*p3->c[2];
  }
  
  /* memory alloc for temp distance */
  dtmp = (double*)calloc(mesh->np+1,sizeof(double));
  assert(dtmp);
  
  /* init dtmp with sol */
  memcpy(&dtmp[0],&sol->val[0],(mesh->np+1)*sizeof(double));

  maxit = 500;
  it    = 1;
  dt    = 0.005;
  res0  = 0.0;
  do {
    base = ++mesh->flag;

    for(k=1; k<=mesh->ne; k++) {
      pt = &mesh->tetra[k]; 
      iadr = 16 * (k-1) + 1;
      dx = sol->val[pt->v[0]] * gradients[iadr+0] + sol->val[pt->v[1]] * gradients[iadr+4]
         + sol->val[pt->v[2]] * gradients[iadr+8] + sol->val[pt->v[3]] * gradients[iadr+12];
      dy = sol->val[pt->v[0]] * gradients[iadr+1] + sol->val[pt->v[1]] * gradients[iadr+5] 
         + sol->val[pt->v[2]] * gradients[iadr+9] + sol->val[pt->v[3]] * gradients[iadr+13];
      dz = sol->val[pt->v[0]] * gradients[iadr+2] + sol->val[pt->v[1]] * gradients[iadr+6] 
         + sol->val[pt->v[2]] * gradients[iadr+10] + sol->val[pt->v[3]] * gradients[iadr+14];
      dd = sqrt(dx*dx + dy*dy + dz*dz); 

      /* vector to track characteristic line */
      if ( dd < EPS1 )  continue;
      dd = dt / dd;
      dx *= dd;
      dy *= dd;
      dz *= dd;

      for (j=0; j<4; j++) {
        ip = pt->v[j];
        p0 = &mesh->point[ip];
        if ( p0->tag == 1 )  continue;
        else if ( p0->flag && p0->flag < base-1 )  continue;

        if ( fabs(sol->val[ip]) < EPS1 )
          continue;
        else if ( sol->val[ip] > 0.0 ) {
          p[0] = p0->c[0] - dx; 
          p[1] = p0->c[1] - dy; 
          p[2] = p0->c[2] - dz;
        }
        else {
          p[0] = p0->c[0] + dx; 
          p[1] = p0->c[1] + dy; 
          p[2] = p0->c[2] + dz;
        }
        if ( p[0] <= EPS1 || p[0] >= 1.0-EPS1 )  continue;
        if ( p[1] <= EPS1 || p[1] >= 1.0-EPS1 )  continue;
        if ( p[2] <= EPS1 || p[2] >= 1.0-EPS1 )  continue;
        
        /* find enclosing triangle, k is guessed */ 
        iel = locelt(mesh,k,p,cb);
        if ( iel < 1 ) {
          fprintf(stdout,"  ## No simplex found. Exit.\n"); 
          exit(1);
        }  

        /* P1 Lagrange interpolation */
        pt1  = &mesh->tetra[iel]; 
        iadr = 16 * (iel-1) + 1;  
        drec = sol->val[pt1->v[0]] * (p[0]*gradients[iadr+0]  + p[1]*gradients[iadr+1]  + p[2]*gradients[iadr+2] + gradients[iadr+3])
             + sol->val[pt1->v[1]] * (p[0]*gradients[iadr+4]  + p[1]*gradients[iadr+5]  + p[2]*gradients[iadr+6] + gradients[iadr+7])
             + sol->val[pt1->v[2]] * (p[0]*gradients[iadr+8]  + p[1]*gradients[iadr+9]  + p[2]*gradients[iadr+10] + gradients[iadr+11])
             + sol->val[pt1->v[3]] * (p[0]*gradients[iadr+12] + p[1]*gradients[iadr+13] + p[2]*gradients[iadr+14] + gradients[iadr+15]);

        if ( (dtmp[ip] > 0.0) && (drec + dt > 0.0) ) {
          dtmp[ip] = D_MIN(dtmp[ip],drec + dt);
        }
        else if ( (dtmp[ip] < 0.0) && (drec - dt < 0.0) ) {
          dtmp[ip] = D_MAX(dtmp[ip],drec - dt);
        }   
      } 
    }
    
    /* update sol */
    res = 0.0;
    for (k=1; k<=mesh->np; k++) {
      p0 = &mesh->point[k];
      if ( p0->tag )  continue;
      else if ( p0->flag && p0->flag < base-2 )  continue;

      if ( fabs(dtmp[k]) < EPS1 )  continue;
      else if ( (sol->val[k] < 0.0) && (dtmp[k] < 0.0) ) {
        if ( dtmp[k] > sol->val[k] ) {
          res += dtmp[k] - sol->val[k];
          sol->val[k] = dtmp[k];
          p0->flag = base;
        }
      }  
      else if ( (sol->val[k] > 0.0) && (dtmp[k] > 0.0) ) {
        if ( dtmp[k] < sol->val[k] ) {
          res += sol->val[k] - dtmp[k];
          sol->val[k] = dtmp[k];
          p0->flag = base;
        }
      }
    }
    if ( it == 1 )  res0 = res;
    else if ( res < EPS * res0 )  break;
    fprintf(stdout,"     %9.7f  %8d\r",res/res0,it);  fflush(stdout);
  }
  while ( ++ it < maxit );
    
  fprintf(stdout,"     Residual %E after %d iterations\n",res / res0,it);
  free(gradients);
  free(dtmp);

  return(1);
}


/* expand distance function to the entire domain by solving the Eikonal eq. using characteristics */
int ppgdist_2d(pMesh mesh,pSol sol) {
  pTria     pt,pt1;
  pPoint    p0,p1,p2;
  double   *gradients,*dtmp,drec,v0x,v0y,v1x,v1y,v2x,v2y,det,dd,dx,dy,dt,p[2],cb[3],res,res0;
  int       j,k,ip,iadr,it,maxit,iel,base;

  /* memory alloc */
  gradients = (double*)calloc(9*(mesh->nt)+1,sizeof(double));
  assert(gradients);

  /* compute gradients of shape functions P1: 9 values (dx,dy,cte) */
  for (k=1; k<=mesh->nt; k++) {
    pt = &mesh->tria[k]; 
    p0 = &mesh->point[pt->v[0]];
    p1 = &mesh->point[pt->v[1]];
    p2 = &mesh->point[pt->v[2]];
    
    /* lambda_0 */
    v1x = p1->c[0] - p0->c[0]; 
    v1y = p1->c[1] - p0->c[1];
    v2x = p2->c[0] - p0->c[0];
    v2y = p2->c[1] - p0->c[1];
    det = v1x*v2y - v2x*v1y;
    dx  = dy = 0.0;
    if ( fabs(det) > EPS1 ) {
      det = 1.0 / det; 
      dx = (-v2y + v1y) * det;
      dy = ( v2x - v1x) * det;
    }
    iadr = 9 * (k-1) + 1;
    gradients[iadr + 0] = dx;    
    gradients[iadr + 1] = dy;
    gradients[iadr + 2] = 1.0 - dx*(p0->c[0]) - dy*(p0->c[1]);

    /* lambda_1 */
    v0x = -v1x;
    v0y = -v1y;
    v2x = p2->c[0] - p1->c[0];
    v2y = p2->c[1] - p1->c[1];
    det = v0x*v2y - v2x*v0y;
    dx  = dy = 0.0; 
    if ( fabs(det) > EPS1 ) {
      det = 1.0 / det;
      dx  = (-v2y + v0y) * det;
      dy  = ( v2x - v0x) * det;
    }
    gradients[iadr + 3] = dx;    
    gradients[iadr + 4] = dy;
    gradients[iadr + 5] = 1.0 - dx*(p1->c[0]) - dy*(p1->c[1]);
    
    /* lambda_2 */
    v0x = p0->c[0] - p2->c[0]; 
    v0y = p0->c[1] - p2->c[1];
    v1x = p1->c[0] - p2->c[0];
    v1y = p1->c[1] - p2->c[1];
    det = v0x*v1y - v1x*v0y;
    dx = dy = 0.0;
    if ( fabs(det) > EPS1 ) {
      det = 1.0 / det;
      dx  = (-v1y + v0y) * det;
      dy  = ( v1x - v0x) * det;
    }
    gradients[iadr + 6] = dx;
    gradients[iadr + 7] = dy;
    gradients[iadr + 8] = 1.0 - dx*(p2->c[0]) - dy*(p2->c[1]);
  }

  /* memory alloc for temp distance */
  dtmp = (double*)calloc(mesh->np+1,sizeof(double));
  assert(dtmp);

  /* init dtmp with sol */
  memcpy(&dtmp[0],&sol->val[0],(mesh->np+1)*sizeof(double));

  maxit = 500;
  it    = 1;
  dt    = 0.0015;
  res0  = 0.0;
  do {
    base = ++mesh->flag;

    for (k=1; k<=mesh->nt; k++) {
      pt   = &mesh->tria[k]; 
      iadr = 9 * (k-1) + 1;
      dx = sol->val[pt->v[0]] * gradients[iadr+0] + sol->val[pt->v[1]]*gradients[iadr+3] 
         + sol->val[pt->v[2]] * gradients[iadr+6];
      dy = sol->val[pt->v[0]] * gradients[iadr+1] + sol->val[pt->v[1]] * gradients[iadr+4]
         + sol->val[pt->v[2]] * gradients[iadr+7];
      dd = sqrt(dx*dx + dy*dy); 

      /* vector to track characteristic line */
      if ( dd < EPS1 )  continue;
      dd = dt / dd;
      dx *= dd;
      dy *= dd;

      for (j=0; j<3; j++) {
        ip = pt->v[j];
        p0 = &mesh->point[ip];
        if ( p0->tag == 1 )  continue;
        else if ( p0->flag && p0->flag < base-1 )  continue;

        /* follow characteristic line */
        if ( fabs(sol->val[ip]) < EPS1 )
          continue;
        else if ( sol->val[ip] > 0.0 ) {
          p[0] = p0->c[0] - dx; 
          p[1] = p0->c[1] - dy;
        }
        else {
          p[0] = p0->c[0] + dx; 
          p[1] = p0->c[1] + dy;
        }
        if ( p[0] <= EPS1 || p[0] >= 1.0-EPS1 )  continue;
        if ( p[1] <= EPS1 || p[1] >= 1.0-EPS1 )  continue;

        /* find enclosing triangle, k is guessed */ 
        iel = locelt(mesh,k,p,cb);
        if ( iel < 1 ) {
          fprintf(stdout,"  ## No simplex found. Exit.\n"); 
          exit(1);
        }  

        /* P1 Lagrange interpolation */
        pt1  = &mesh->tria[iel]; 
        iadr = 9 * (iel-1) + 1;
        drec = sol->val[pt1->v[0]] * (p[0]*gradients[iadr+0] + p[1]*gradients[iadr+1] + gradients[iadr+2])
             + sol->val[pt1->v[1]] * (p[0]*gradients[iadr+3] + p[1]*gradients[iadr+4] + gradients[iadr+5])
             + sol->val[pt1->v[2]] * (p[0]*gradients[iadr+6] + p[1]*gradients[iadr+7] + gradients[iadr+8]);   

        if ( (dtmp[ip] > 0.0) && (drec + dt > 0.0) ) {
          dtmp[ip] = D_MIN(dtmp[ip],drec + dt);
        }
        else if ( (dtmp[ip] < 0.0) && (drec - dt < 0.0) ) {
          dtmp[ip] = D_MAX(dtmp[ip],drec - dt);
        }
      }
    }

    /* update sol */ 
    res = 0.0;
    for (k=1; k<=mesh->np; k++) {
      p0 = &mesh->point[k];
      if ( p0->tag )  continue;
      else if ( p0->flag && p0->flag < base-2 )  continue;

      if ( fabs(dtmp[k]) < EPS1 )  continue;
      else if ( (sol->val[k] < 0.0) && (dtmp[k] < 0.0) ) {
        if ( dtmp[k] > sol->val[k] ) {
          res += dtmp[k] - sol->val[k];
          sol->val[k] = dtmp[k];
          p0->flag = base;
        }
      }  
      else if ( (sol->val[k] > 0.0) && (dtmp[k] > 0.0) ) {
        if ( dtmp[k] < sol->val[k] ) {
          res += sol->val[k] - dtmp[k];
          sol->val[k] = dtmp[k];
          p0->flag = base;
        } 
      }
    }
    if ( it == 1 )  res0 = res;
    else if ( res < EPS * res0 )  break;
    fprintf(stdout,"     %9.7f  %8d\r",res/res0,it);  fflush(stdout);
  }
  while ( ++ it < maxit );

  fprintf(stdout,"     Residual %E after %d iterations\n",res / res0,it);
  free(gradients);
  free(dtmp);

  return(1);
}


int mshdis1(pMesh mesh1,pMesh mesh2,pSol sol1) {
  pBucket  bucket;
  int      k,ier;

  /* alloc memory */
  sol1->dim = mesh1->dim;
  sol1->np  = mesh1->np;
  sol1->ver = GmfDouble;
  sol1->bin = mesh1->bin;
  sol1->size[0] = 1;
  sol1->type[0] = 1;
  sol1->typtab[0][0] = GmfSca;

  /* init distance */
  sol1->val = (double*)malloc((sol1->np+1)*sizeof(double));
  assert(sol1->val);
  if ( mesh1->dim == 2 )
    for (k=1; k<=sol1->np; k++)  sol1->val[k] = INIVAL_2d;
  else
    for (k=1; k<=sol1->np; k++)  sol1->val[k] = INIVAL_3d;

  /* bucket sort */
  bucket = newBucket(mesh1,BUCKSIZ);
  if ( !bucket )  return(0);

  if ( info.imprim )  fprintf(stdout,"  ** Initialization\n");
  ier = inidist(mesh1,mesh2,sol1,bucket);
  if ( info.imprim )  fprintf(stdout,"  ** Sign identification\n");
  ier = sgndist(mesh1,sol1,bucket);
/*
{
  pPoint  p1;
  double  dd;
  for (k=1; k<=mesh1->np; k++) {
    p1 = &mesh1->point[k];
    dd = (p1->c[0]-0.5)*(p1->c[0]-0.5) + (p1->c[1]-0.5)*(p1->c[1]-0.5) + (p1->c[2]-0.5)*(p1->c[2]-0.5);
    dd = sqrt(dd) - 0.375;
    if ( dd > 0.0 ) 
      sol1->val[k] = fabs(sol1->val[k]); 
    else
      sol1->val[k] = -fabs(sol1->val[k]);
  }
}
*/
return(1);
  if ( ier > 0 ) {
    if ( info.imprim )  fprintf(stdout,"  ** Propagation\n");
    ier = ppgdist(mesh1,sol1);
  }

  freeBucket(bucket);
  return(1);
}

